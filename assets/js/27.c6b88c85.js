(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{515:function(t,p,s){"use strict";s.r(p);var v=s(2),i=Object(v.a)({},(function(){var t=this,p=t.$createElement,s=t._self._c||p;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("div",{staticClass:"custom-block tip"},[s("p",[t._v("神经网络基础结构"),s("br")])]),t._v(" "),s("p",[t._v("感知器：一种人工神经单元。")]),t._v(" "),s("p",[t._v("感知器要求有多个二进制的输入，但只生成一个二进制的输出。利用权重来衡量各个输入的重要性。将输入的加权和与已经设定好的阈值作比较，根据比较的结果来判别感知器的输出结果。通过改变权重和阈值，可以得到不同的决策模型。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://img1.imgtp.com/2023/05/26/a3qkseFb.png",alt:""}})]),t._v(" "),s("p",[t._v("一般来说，越复杂的网络越有助于我们在让计算机决策时做出更微妙的决定。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://img1.imgtp.com/2023/05/26/aQlg9Ff4.png",alt:""}})]),t._v(" "),s("p",[t._v("上图中有三个感知层，每一层上的每一个感知器单元都是在根据上层感知器单元传递的值和权重来调整自己的输出，每个感知器单元的输出都是单个的输出，但是每个输出又作用于下一层不同的感知器单元上边。每一次作用都有自己特有的权重，权重较大，该感知器单元就在决策中占据更为重要的地位；权重较小，该感知器单元就不那么重要，甚至于不被激活。")]),t._v(" "),s("p",[t._v("但是我们一遍遍的拿每一个感知器的结果来和阈值作比较，未免显得过于麻烦。因此我们将阈值从不等号的右边拿到左边来，即成为：")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://img1.imgtp.com/2023/05/26/k01QcN9J.png",alt:""}})]),t._v(" "),s("p",[t._v("b就是我们常说的偏置项。偏置项用来衡量感知器单元激活的难易程度，偏置项越大，相应的感知器单元就越难激活，偏执器越小，相应的感知器单元就越容易触发。对应到人类的决策中来，当你越喜欢一件事情，那么这件事就越容易被激活。如果你非常喜欢某个乐队，当他们要举办音乐会的时候，可能你并不会考虑自己是否需要上班，是否有人陪，是否交通方便。因为喜欢，此时的偏置项就会显得非常小，影响你做出决定的三个因素就显得没那么重要，甚至于不被满足也没关系。感知器就是这么一种，权衡证据以做出决定的方法。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://img1.imgtp.com/2023/05/26/7LnYhyij.png",alt:""}})]),t._v(" "),s("p",[t._v("感知器网络中，任何单个神经元的权重或者偏置项产生微小变化时，都有可能会导致该神经元的输出完全反转。这种从0到1的反转极有可能会导致网络的其余部分以某种非常复杂的方式发生变化。但是我们想要的是，微小的改变带来的是微小的改变。因此我们对输出进行一种修饰，即对每一个即将输出的加权和加上一个修饰函数，这就成为了我们常见的激活函数。")]),t._v(" "),s("p",[t._v("sigmoid激活函数是我们常见的激活函数：")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://img1.imgtp.com/2023/05/26/7LnYhyij.png",alt:""}})]),t._v(" "),s("p",[s("img",{attrs:{src:"https://img1.imgtp.com/2023/05/26/PwW9GvPR.jpg",alt:""}})]),t._v(" "),s("p",[t._v("激活函数在每一层都起作用，而不仅仅是在最后的输出层。在激活函数对结果进行修饰后，我们又该如何判别输出结果是否是我们想要的哪？此时引入损失函数来描述我们期望的结果与输出结果间的偏差。即损失函数=期望值与实际值的偏差。损失函数越小，意味着输出的结果越靠近我们的期望值。损失函数越大，那不言而喻，输出的结果肯定一塌糊涂。")]),t._v(" "),s("p",[t._v("到目前为止，我们一直在讨论神经网络，其上一层的输出被用作下一层的输入。这种网络称为前馈神经网络。这意味着网络是没有环路的，每一层的信息只能往下一层传递下去，从不反馈。当我们发现输出的结果并不是我们想要的结果时，我们就会好奇：到底该如何修改我的权重和偏置项，才能在既定的输入下得到我想要的输出哪？这里就要引入反向传播算法。反向传播算法就好像有一个人在告诉你，该如何调整每一层的权重和偏执。尽管他也不能一次就把每一个值都调整到位，但是他却知道如何一步一步的让期望值逼近实际值，即损失函数尽可能的小。")]),t._v(" "),s("p",[t._v("反向传播算法的理念我们知道了，如何实现又成了另一个问题。不要着急，梯度下降法就是一个寻求损失函数最小值的过程。梯度就是函数变大最快的方向，我们用梯度去找到损失函数变大最快的方向，再让损失函数向相反的方向移动，直至梯度变为0，损失函数不再移动，我们就找到了损失函数的最小值。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://img1.imgtp.com/2023/05/25/X26mBiKG.png",alt:""}})]),t._v(" "),s("p",[t._v("至此，神经网络的运行原理全部结束。")]),t._v(" "),s("p",[t._v("从输入和权重、到激活函数、到反向传播，到梯度下降，就是一个简单神经网络的全部过程。当然，经过重复的训练才能完成一个具有一定功能的神经网络。不同的激活函数，不同的损失函数，不同的下降算法都会对神经网络的训练带来影响，各种方法之间的优缺点，不同的训练次数都会影响最终的结果。")])])}),[],!1,null,null,null);p.default=i.exports}}]);